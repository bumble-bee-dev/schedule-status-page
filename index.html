<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Personal Status Schedule</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: #f0f0f0;
            color: #333;
            margin: 0;
            text-align: center;
        }

        h1 {
            margin-bottom: 0.5em;
        }

        #time {
            font-size: 1.1em;
            margin-bottom: 1em;
        }

        #status {
            font-size: 1.5em;
            font-weight: bold;
            padding: 0.6em 1.4em;
            border-radius: 10px;
            color: white;
            margin-bottom: 1em;
            min-width: 140px;
        }

        #nextChange {
            font-size: 1.1em;
        }

        .next-status {
            font-weight: bold;
            padding: 0.2em 0.4em;
            border-radius: 6px;
            color: white;
        }
    </style>
</head>
<body>
<h1>Schedule</h1>
<div id="time"></div>
<div id="status"></div>
<div id="nextChange"></div>

<script>
    const weekday = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
    const schedule = {
        "statuses": {
            "Available": "green",
            "Working": "red",
            "Sleeping": "navy"
        },
        "weekly": {
            // 0 = Sunday, 6 = Saturday
            "1": [ // Monday
                ["00:00", "09:00", "Sleeping"],
                ["09:00", "18:00", "Working"],
                ["23:00", "24:00", "Sleeping"]
            ],
            "2": [ // Tuesday
                ["00:00", "09:00", "Sleeping"],
                ["09:00", "18:00", "Working"],
                ["23:00", "24:00", "Sleeping"]
            ],
            "3": [ // Wednesday
                ["00:00", "09:00", "Sleeping"],
                ["09:00", "18:00", "Working"],
                ["23:00", "24:00", "Sleeping"]
            ],
            "4": [ // Thursday
                ["00:00", "09:00", "Sleeping"],
                ["09:00", "18:00", "Working"],
                ["23:00", "24:00", "Sleeping"]
            ],
            "5": [ // Friday
                ["00:00", "09:00", "Sleeping"],
                ["09:00", "18:00", "Working"],
                ["23:00", "24:00", "Sleeping"]
            ],
            "6": [ // Saturday
                ["00:00", "09:00", "Sleeping"],
                ["23:00", "24:00", "Sleeping"]
            ],
            "0": [ // Sunday
                ["00:00", "09:00", "Sleeping"],
                ["23:00", "24:00", "Sleeping"]
            ]
        }
    };

    // Get current UK time as a proper Date object
    function getUKTime() {
        // Get the current time in UK timezone
        const ukDateString = new Date().toLocaleString("en-US", { timeZone: "Europe/London" });
        return new Date(ukDateString);
    }

    // Utility: convert "HH:MM" → total minutes
    function parseTime(str) {
        const [h, m] = str.split(":").map(Number);
        return h * 60 + (m || 0);
    }

    // Determine current and next status
    function getCurrentStatus(date, schedule) {
        const day = date.getDay();
        const minsNow = date.getHours() * 60 + date.getMinutes();
        const daySchedule = schedule.weekly[day] || [];

        let currentStatus = null;
        let nextStatus = null;
        let nextChangeDate = null;

        // First, check if we're currently in a scheduled block
        for (let i = 0; i < daySchedule.length; i++) {
            const [start, end, status] = daySchedule[i];
            const startM = parseTime(start);
            const endM = parseTime(end);

            if (minsNow >= startM && minsNow < endM) {
                currentStatus = status;
                // Next change → end of this block
                if (i + 1 < daySchedule.length) {
                    nextStatus = daySchedule[i + 1][2];
                    nextChangeDate = new Date(date);
                    nextChangeDate.setHours(Math.floor(endM / 60), endM % 60, 0, 0);
                } else {
                    // No more entries today, find next day
                    [nextStatus, nextChangeDate] = findNextDayStatus(date, day, schedule);
                }
                break;
            }
        }

        // If not in a scheduled block, check if we're before or after
        if (!currentStatus) {
            // Check if we're before the first scheduled item today
            if (daySchedule.length > 0 && minsNow < parseTime(daySchedule[0][0])) {
                currentStatus = "Available";
                nextStatus = daySchedule[0][2];
                const nextStartM = parseTime(daySchedule[0][0]);
                nextChangeDate = new Date(date);
                nextChangeDate.setHours(Math.floor(nextStartM / 60), nextStartM % 60, 0, 0);
            } else {
                // We're after the last scheduled item (or no schedule today)
                currentStatus = "Available";
                [nextStatus, nextChangeDate] = findNextScheduledItem(date, day, schedule);
            }
        }

        return {currentStatus, nextStatus, nextChangeDate};
    }

    // Helper: Find the next scheduled item starting from the next day
    function findNextDayStatus(date, currentDay, schedule) {
        let offset = 1;
        while (offset <= 7) {
            const nextDay = (currentDay + offset) % 7;
            const nextDaySchedule = schedule.weekly[nextDay];
            if (nextDaySchedule && nextDaySchedule.length > 0) {
                const [nStart, , nStatus] = nextDaySchedule[0];
                const nextStartM = parseTime(nStart);
                const nextChangeDate = new Date(date);
                nextChangeDate.setDate(date.getDate() + offset);
                nextChangeDate.setHours(Math.floor(nextStartM / 60), nextStartM % 60, 0, 0);
                return [nStatus, nextChangeDate];
            }
            offset++;
        }
        return [null, null];
    }

    // Helper: Find the next scheduled item (checking rest of today, then future days)
    function findNextScheduledItem(date, currentDay, schedule) {
        const minsNow = date.getHours() * 60 + date.getMinutes();
        const daySchedule = schedule.weekly[currentDay] || [];

        // Check if there are any items later today
        for (let i = 0; i < daySchedule.length; i++) {
            const [start, , status] = daySchedule[i];
            const startM = parseTime(start);
            if (minsNow < startM) {
                const nextChangeDate = new Date(date);
                nextChangeDate.setHours(Math.floor(startM / 60), startM % 60, 0, 0);
                return [status, nextChangeDate];
            }
        }

        // No items later today, check future days
        return findNextDayStatus(date, currentDay, schedule);
    }

    // Update display
    function updateDisplay() {
        const now = getUKTime();
        const {currentStatus, nextStatus, nextChangeDate} = getCurrentStatus(now, schedule);

        const timeDiv = document.getElementById("time");
        const statusDiv = document.getElementById("status");
        const nextDiv = document.getElementById("nextChange");

        timeDiv.textContent = `Current time:  ${weekday[now.getDay()]} ${now.toLocaleString('en-GB', { timeZone: 'Europe/London' })} (UK)`;
        statusDiv.textContent = currentStatus;
        statusDiv.style.backgroundColor = schedule.statuses[currentStatus] || "#777";

        if (nextStatus && nextChangeDate) {
            const diffMs = nextChangeDate - now;
            const diffMins = Math.max(0, Math.round(diffMs / 60000));
            const hours = Math.floor(diffMins / 60);
            const mins = diffMins % 60;
            const nextColor = schedule.statuses[nextStatus] || "#777";

            nextDiv.innerHTML = `Changes to
                <span class="next-status" style="background:${nextColor}">${nextStatus} in ${hours}h ${mins}m</span>
          `;
        } else {
            nextDiv.textContent = `No upcoming change scheduled.`;
        }
    }

    updateDisplay();
    setInterval(updateDisplay, 30 * 1000);
</script>
</body>
</html>
